#!/usr/bin/env python3
"""
JSON to Poppy Assembly Converter for Dragon Warrior IV
ðŸŒ· Flower Toolchain Integration

Converts extracted JSON data files to Poppy-compatible assembly source files (.pasm).
This is part of the ðŸŒ· Flower Toolchain build pipeline:

	ROM â†’ ðŸŒº Peony (disassemble) â†’ Source + ðŸŒ¼ Pansy (metadata)
	         â†’ Edit JSON assets â†’
	JSON â†’ json_to_asm.py â†’ .pasm â†’ ðŸŒ¸ Poppy (assemble) â†’ ROM

Usage:
	python json_to_asm.py monsters    # Convert monsters.json to monsters.pasm
	python json_to_asm.py items       # Convert items.json to items.pasm
	python json_to_asm.py all         # Convert all data files

Poppy Assembly Syntax:
	- .db for bytes, .dw for words (little-endian)
	- Labels end with colon (label:)
	- Comments use semicolon (;)
	- Hex values use $ prefix ($ff)
	- All opcodes/values in lowercase
"""

import json
from pathlib import Path
from typing import Dict, List, Any

import click
from rich.console import Console

# Project paths
PROJECT_ROOT = Path(__file__).parent.parent
ASSETS_JSON_DIR = PROJECT_ROOT / "assets" / "json"
SOURCE_DATA_DIR = PROJECT_ROOT / "src" / "data"  # Updated path for Poppy structure

console = Console()


def format_hex_byte(value: int) -> str:
	"""Format a byte value as hex for assembly."""
	return f"${value:02x}"


def format_hex_word(value: int) -> str:
	"""Format a 16-bit word as hex for assembly."""
	return f"${value:04x}"


def sanitize_label(name: str) -> str:
	"""Convert a name to a valid assembly label."""
	# Replace spaces and special chars with underscores
	label = name.lower()
	label = label.replace(" ", "_")
	label = label.replace("-", "_")
	label = label.replace("'", "")
	label = label.replace(".", "")
	label = label.replace(",", "")
	label = label.replace("!", "")
	label = label.replace("?", "")
	label = label.replace("(", "")
	label = label.replace(")", "")
	# Ensure it starts with a letter
	if label and label[0].isdigit():
		label = "_" + label
	return label


class JsonToAsmConverter:
	"""
	Converts JSON data to Poppy assembly source (.pasm files).

	ðŸŒ· Flower Toolchain component for asset pipeline integration.
	Generates properly formatted assembly code with:
	- Full comments documenting data structures
	- Named labels for each entry
	- Proper Poppy syntax (.db, .dw directives)
	- Lowercase hex values with $ prefix
	"""

	def __init__(self):
		self.console = Console()

	def convert_monsters(self, input_path: Path, output_path: Path):
		"""
		Convert monster data JSON to Poppy assembly.

		Monster data structure (16 bytes per entry):
		- Offset $00: HP (2 bytes, little-endian)
		- Offset $02: MP (1 byte)
		- Offset $03: Attack (2 bytes, little-endian)
		- Offset $05: Defense (1 byte)
		- Offset $06: Agility (1 byte)
		- Offset $07: Experience (2 bytes, little-endian)
		- Offset $09: Gold (2 bytes, little-endian)
		- Offset $0b: Drop item ID (1 byte)
		- Offset $0c: Drop rate denominator (1 byte, 1/N chance)
		- Offset $0d: Action pattern (1 byte)
		- Offset $0e: Resistances bitmask (1 byte)
		- Offset $0f: Sprite/palette info (1 byte)
		"""
		self.console.print(f"[cyan]ðŸŒ· Converting monsters: {input_path}[/cyan]")

		with open(input_path, "r", encoding="utf-8") as f:
			data = json.load(f)

		lines = [
			"; ============================================================================",
			"; Dragon Warrior IV - Monster Data",
			"; ðŸŒ· Generated by json_to_asm.py for Poppy assembler",
			"; ============================================================================",
			";",
			"; Monster data structure (16 bytes per entry):",
			";   Offset  Size  Description",
			";   $00     2     HP (little-endian word)",
			";   $02     1     MP",
			";   $03     2     Attack (little-endian word)",
			";   $05     1     Defense",
			";   $06     1     Agility",
			";   $07     2     Experience (little-endian word)",
			";   $09     2     Gold (little-endian word)",
			";   $0b     1     Drop item ID",
			";   $0c     1     Drop rate (1/N chance)",
			";   $0d     1     Action pattern",
			";   $0e     1     Resistances (bitmask)",
			";   $0f     1     Sprite/palette info",
			";",
			"; ============================================================================",
			"",
			"; -----------------------------------------------------------------------------",
			"; Monster count constant",
			"; -----------------------------------------------------------------------------",
			f"MONSTER_COUNT = {len(data.get('monsters', []))}",
			"",
			"; -----------------------------------------------------------------------------",
			"; Monster stat table",
			"; Located in PRG Bank 08",
			"; -----------------------------------------------------------------------------",
			"monster_stats_table:",
		]

		monsters = data.get("monsters", [])
		for monster in monsters:
			monster_id = monster.get("id", 0)
			name = monster.get("name", f"Monster_{monster_id:03d}")
			hp = monster.get("hp", 0)
			mp = monster.get("mp", 0)
			attack = monster.get("attack", 0)
			defense = monster.get("defense", 0)
			agility = monster.get("agility", 0)
			exp = monster.get("exp", 0)
			gold = monster.get("gold", 0)
			drop_item = monster.get("drop_item_id", 0)
			drop_rate = monster.get("drop_rate", 0)
			action = monster.get("action_pattern", 0)
			resist = monster.get("resistances", 0)
			sprite = monster.get("sprite_info", 0)

			# Create sanitized label from name
			label = sanitize_label(name)

			lines.append(f"")
			lines.append(f"; Monster ${monster_id:02x}: {name}")
			lines.append(f"monster_{monster_id:03d}:")
			lines.append(f"monster_{label}:")
			lines.append(f"\t.dw {format_hex_word(hp)}\t\t\t; HP = {hp}")
			lines.append(f"\t.db {format_hex_byte(mp)}\t\t\t\t; MP = {mp}")
			lines.append(f"\t.dw {format_hex_word(attack)}\t\t\t; Attack = {attack}")
			lines.append(f"\t.db {format_hex_byte(defense)}\t\t\t\t; Defense = {defense}")
			lines.append(f"\t.db {format_hex_byte(agility)}\t\t\t\t; Agility = {agility}")
			lines.append(f"\t.dw {format_hex_word(exp)}\t\t\t; Experience = {exp}")
			lines.append(f"\t.dw {format_hex_word(gold)}\t\t\t; Gold = {gold}")
			lines.append(f"\t.db {format_hex_byte(drop_item)}\t\t\t\t; Drop item ID")
			lines.append(f"\t.db {format_hex_byte(drop_rate)}\t\t\t\t; Drop rate (1/{drop_rate if drop_rate else 'N/A'})")
			lines.append(f"\t.db {format_hex_byte(action)}\t\t\t\t; Action pattern")
			lines.append(f"\t.db {format_hex_byte(resist)}\t\t\t\t; Resistances")
			lines.append(f"\t.db {format_hex_byte(sprite)}\t\t\t\t; Sprite info")

		lines.extend([
			"",
			"; ============================================================================",
			"; End of monster data",
			"; ============================================================================",
		])

		output_path.parent.mkdir(parents=True, exist_ok=True)
		with open(output_path, "w", encoding="utf-8") as f:
			f.write("\n".join(lines))

		self.console.print(f"[green]âœ“ Written {len(monsters)} monsters to {output_path}[/green]")

	def convert_items(self, input_path: Path, output_path: Path):
		"""
		Convert item data JSON to Poppy assembly.

		Item data structure (8 bytes per entry):
		- Offset $00: Price (2 bytes, little-endian)
		- Offset $02: Attack bonus (1 byte)
		- Offset $03: Defense bonus (1 byte)
		- Offset $04: Agility bonus (1 byte, signed)
		- Offset $05: Equip flags (1 byte, bitmask for who can equip)
		- Offset $06: Effect ID (1 byte)
		- Offset $07: Item type (1 byte)
		"""
		self.console.print(f"[cyan]ðŸŒ· Converting items: {input_path}[/cyan]")

		with open(input_path, "r", encoding="utf-8") as f:
			data = json.load(f)

		lines = [
			"; ============================================================================",
			"; Dragon Warrior IV - Item Data",
			"; ðŸŒ· Generated by json_to_asm.py for Poppy assembler",
			"; ============================================================================",
			";",
			"; Item data structure (8 bytes per entry):",
			";   Offset  Size  Description",
			";   $00     2     Price (little-endian word)",
			";   $02     1     Attack bonus",
			";   $03     1     Defense bonus",
			";   $04     1     Agility bonus (signed byte)",
			";   $05     1     Equip flags (who can equip)",
			";   $06     1     Effect ID",
			";   $07     1     Item type",
			";",
			"; Equip flags bitmask:",
			";   Bit 0: Hero        Bit 4: Alena",
			";   Bit 1: Ragnar      Bit 5: Brey",
			";   Bit 2: Taloon      Bit 6: Cristo",
			";   Bit 3: Nara        Bit 7: Mara",
			";",
			"; ============================================================================",
			"",
			"; -----------------------------------------------------------------------------",
			"; Item count constant",
			"; -----------------------------------------------------------------------------",
			f"ITEM_COUNT = {len(data.get('items', []))}",
			"",
			"; -----------------------------------------------------------------------------",
			"; Item stat table",
			"; Located in PRG Bank 08",
			"; -----------------------------------------------------------------------------",
			"item_stats_table:",
		]

		items = data.get("items", [])
		for item in items:
			item_id = item.get("id", 0)
			name = item.get("name", f"Item_{item_id:03d}")
			price = item.get("price", 0)
			attack = item.get("attack_bonus", 0)
			defense = item.get("defense_bonus", 0)
			agility = item.get("agility_bonus", 0)
			equip = item.get("equip_flags", 0)
			effect = item.get("effect_id", 0)
			item_type = item.get("item_type", 0)

			# Handle signed agility bonus (convert negative to unsigned byte)
			if agility < 0:
				agility = 256 + agility

			# Create sanitized label from name
			label = sanitize_label(name)

			lines.append(f"")
			lines.append(f"; Item ${item_id:02x}: {name}")
			lines.append(f"item_{item_id:03d}:")
			lines.append(f"item_{label}:")
			lines.append(f"\t.dw {format_hex_word(price)}\t\t\t; Price = {price}G")
			lines.append(f"\t.db {format_hex_byte(attack)}\t\t\t\t; Attack +{attack}")
			lines.append(f"\t.db {format_hex_byte(defense)}\t\t\t\t; Defense +{defense}")
			lines.append(f"\t.db {format_hex_byte(agility)}\t\t\t\t; Agility bonus")
			lines.append(f"\t.db {format_hex_byte(equip)}\t\t\t\t; Equip flags")
			lines.append(f"\t.db {format_hex_byte(effect)}\t\t\t\t; Effect ID")
			lines.append(f"\t.db {format_hex_byte(item_type)}\t\t\t\t; Item type")

		lines.extend([
			"",
			"; ============================================================================",
			"; End of item data",
			"; ============================================================================",
		])

		output_path.parent.mkdir(parents=True, exist_ok=True)
		with open(output_path, "w", encoding="utf-8") as f:
			f.write("\n".join(lines))

		self.console.print(f"[green]âœ“ Written {len(items)} items to {output_path}[/green]")

	def convert_spells(self, input_path: Path, output_path: Path):
		"""
		Convert spell data JSON to Poppy assembly.

		Spell data structure (8 bytes per entry):
		- Offset $00: MP cost (1 byte)
		- Offset $01: Effect type (1 byte)
		- Offset $02: Power/healing amount (1 byte)
		- Offset $03: Target type (1 byte)
		- Offset $04: Element (1 byte)
		- Offset $05: Accuracy (1 byte)
		- Offset $06: Flags (2 bytes, little-endian)
		"""
		self.console.print(f"[cyan]ðŸŒ· Converting spells: {input_path}[/cyan]")

		with open(input_path, "r", encoding="utf-8") as f:
			data = json.load(f)

		lines = [
			"; ============================================================================",
			"; Dragon Warrior IV - Spell Data",
			"; ðŸŒ· Generated by json_to_asm.py for Poppy assembler",
			"; ============================================================================",
			";",
			"; Spell data structure (8 bytes per entry):",
			";   Offset  Size  Description",
			";   $00     1     MP cost",
			";   $01     1     Effect type",
			";   $02     1     Power/healing amount",
			";   $03     1     Target type (0=self, 1=ally, 2=all, 3=enemy, 4=group)",
			";   $04     1     Element (0=none, 1=fire, 2=ice, 3=electric, etc.)",
			";   $05     1     Accuracy (0-255)",
			";   $06     2     Flags (little-endian word)",
			";",
			"; ============================================================================",
			"",
			"; -----------------------------------------------------------------------------",
			"; Spell count constant",
			"; -----------------------------------------------------------------------------",
			f"SPELL_COUNT = {len(data.get('spells', []))}",
			"",
			"; -----------------------------------------------------------------------------",
			"; Spell data table",
			"; Located in PRG Bank 08",
			"; -----------------------------------------------------------------------------",
			"spell_data_table:",
		]

		spells = data.get("spells", [])
		for spell in spells:
			spell_id = spell.get("id", 0)
			name = spell.get("name", f"Spell_{spell_id:03d}")
			mp_cost = spell.get("mp_cost", 0)
			effect = spell.get("effect_type", 0)
			power = spell.get("power", 0)
			target = spell.get("target_type", 0)
			element = spell.get("element", 0)
			accuracy = spell.get("accuracy", 100)
			flags = spell.get("flags", 0)

			# Create sanitized label from name
			label = sanitize_label(name)

			lines.append(f"")
			lines.append(f"; Spell ${spell_id:02x}: {name}")
			lines.append(f"spell_{spell_id:03d}:")
			lines.append(f"spell_{label}:")
			lines.append(f"\t.db {format_hex_byte(mp_cost)}\t\t\t\t; MP cost = {mp_cost}")
			lines.append(f"\t.db {format_hex_byte(effect)}\t\t\t\t; Effect type")
			lines.append(f"\t.db {format_hex_byte(power)}\t\t\t\t; Power = {power}")
			lines.append(f"\t.db {format_hex_byte(target)}\t\t\t\t; Target type")
			lines.append(f"\t.db {format_hex_byte(element)}\t\t\t\t; Element")
			lines.append(f"\t.db {format_hex_byte(accuracy)}\t\t\t\t; Accuracy")
			lines.append(f"\t.dw {format_hex_word(flags)}\t\t\t; Flags")

		lines.extend([
			"",
			"; ============================================================================",
			"; End of spell data",
			"; ============================================================================",
		])

		output_path.parent.mkdir(parents=True, exist_ok=True)
		with open(output_path, "w", encoding="utf-8") as f:
			f.write("\n".join(lines))

		self.console.print(f"[green]âœ“ Written {len(spells)} spells to {output_path}[/green]")

	def load_items_lookup(self) -> Dict[int, Dict[str, Any]]:
		"""
		Load item data to create a lookup table for item names.

		Returns a dict mapping item ID -> {name, type, label}
		"""
		items_path = ASSETS_JSON_DIR / "items.json"
		if not items_path.exists():
			return {}

		with open(items_path, "r", encoding="utf-8") as f:
			data = json.load(f)

		lookup = {}
		for item in data.get("items", []):
			# Parse hex ID like "0x00" to int
			item_id_str = item.get("id", "0x00")
			if isinstance(item_id_str, str):
				item_id = int(item_id_str, 16)
			else:
				item_id = item_id_str

			name = item.get("name", f"Item_{item_id:02x}")
			item_type = item.get("type", "unknown")
			label = f"ITEM_{sanitize_label(name).upper()}"

			lookup[item_id] = {
				"name": name,
				"type": item_type,
				"label": label,
			}

		return lookup

	def convert_shops(self, input_path: Path, output_path: Path):
		"""
		Convert shop data JSON to Poppy assembly.

		Shop format: Pointer table followed by item lists.
		Each shop is a list of item IDs terminated by $FF.

		Features:
		- Named labels based on shop location (e.g., shop_burland_weapon)
		- Item IDs replaced with ITEM_* constants
		- Full comments with item names
		"""
		self.console.print(f"[cyan]ðŸŒ· Converting shops: {input_path}[/cyan]")

		with open(input_path, "r", encoding="utf-8") as f:
			data = json.load(f)

		# Load item lookup for name resolution
		items_lookup = self.load_items_lookup()

		lines = [
			"; ============================================================================",
			"; Dragon Warrior IV - Shop Data",
			"; ðŸŒ· Generated by json_to_asm.py for Poppy assembler",
			"; ============================================================================",
			";",
			"; Shop format:",
			";   - Pointer table: .dw shop_xxx, ...",
			";   - Each shop: list of item IDs (ITEM_* constants) terminated by SHOP_END",
			";",
			"; Each shop entry uses symbolic item constants for readability.",
			"; Shop labels are named by location for easy reference.",
			";",
			"; ============================================================================",
			"",
		]

		shops = data.get("shops", [])

		# ---------------------------------------------------------------------
		# Generate shop label from ROM offset and shop ID
		# We'll create meaningful names based on the ROM offset ranges
		# which correspond to different areas/chapters
		# ---------------------------------------------------------------------
		def get_shop_label(shop_data: Dict, index: int) -> str:
			"""Generate a descriptive shop label based on ROM offset."""
			rom_offset = shop_data.get("rom_offset", "0x0")
			if isinstance(rom_offset, str):
				offset = int(rom_offset, 16)
			else:
				offset = rom_offset

			# Map ROM offset ranges to location names
			# These are approximate based on the ROM layout
			if 0x20100 <= offset < 0x20500:
				return f"shop_ch1_{index:03d}"  # Chapter 1 - Ragnar
			elif 0x20500 <= offset < 0x20800:
				return f"shop_ch2_{index:03d}"  # Chapter 2 - Alena
			elif 0x20800 <= offset < 0x21000:
				return f"shop_ch3_{index:03d}"  # Chapter 3 - Taloon
			elif 0x21000 <= offset < 0x21800:
				return f"shop_ch4_{index:03d}"  # Chapter 4 - Sisters
			elif 0x21800 <= offset < 0x22500:
				return f"shop_ch5_{index:03d}"  # Chapter 5 - Hero
			else:
				return f"shop_{index:03d}"

		# Generate shop labels
		shop_labels = []
		for i, shop in enumerate(shops):
			label = get_shop_label(shop, i)
			shop_labels.append(label)

		# ---------------------------------------------------------------------
		# Item constants
		# ---------------------------------------------------------------------
		lines.append("; -----------------------------------------------------------------------------")
		lines.append("; Item ID Constants (for shop data)")
		lines.append("; -----------------------------------------------------------------------------")
		lines.append("")

		# Generate constants for items that appear in shops
		used_items = set()
		for shop in shops:
			for item_id in shop.get("item_ids", []):
				used_items.add(item_id)

		# Sort and output item constants
		for item_id in sorted(used_items):
			if item_id in items_lookup:
				info = items_lookup[item_id]
				name = info["name"]
				label = info["label"]
				lines.append(f"{label} = ${item_id:02x}\t\t; {name}")
			else:
				lines.append(f"ITEM_{item_id:02X} = ${item_id:02x}\t\t; Unknown item ${item_id:02x}")

		lines.append("")
		lines.append("; Shop terminator")
		lines.append("SHOP_END = $ff")
		lines.append("")

		lines.append("; -----------------------------------------------------------------------------")
		lines.append("; Shop count constant")
		lines.append("; -----------------------------------------------------------------------------")
		lines.append(f"SHOP_COUNT = {len(shops)}")
		lines.append("")

		# ---------------------------------------------------------------------
		# Pointer table
		# ---------------------------------------------------------------------
		lines.append("; -----------------------------------------------------------------------------")
		lines.append("; Shop pointer table")
		lines.append("; -----------------------------------------------------------------------------")
		lines.append("shop_pointer_table:")
		for i, shop in enumerate(shops):
			label = shop_labels[i]
			item_ids = shop.get("item_ids", [])
			# Generate a descriptive comment
			if item_ids and item_ids[0] in items_lookup:
				first_item = items_lookup[item_ids[0]]["name"]
				lines.append(f"\t.dw {label}\t\t; Shop {i}: {first_item}...")
			else:
				lines.append(f"\t.dw {label}\t\t; Shop {i}")
		lines.append("")

		# ---------------------------------------------------------------------
		# Shop data
		# ---------------------------------------------------------------------
		lines.append("; -----------------------------------------------------------------------------")
		lines.append("; Shop data (item lists)")
		lines.append("; Each shop contains item constants terminated by SHOP_END ($ff)")
		lines.append("; -----------------------------------------------------------------------------")

		for i, shop in enumerate(shops):
			label = shop_labels[i]
			item_ids = shop.get("item_ids", [])
			rom_offset = shop.get("rom_offset", "0x0")

			lines.append(f"")
			lines.append(f"; -----------------------------------------------------------------------------")
			lines.append(f"; Shop ${i:02x} - {label}")
			lines.append(f"; ROM Offset: {rom_offset}")

			# List all items in this shop
			if item_ids:
				item_names = []
				for item_id in item_ids:
					if item_id in items_lookup:
						item_names.append(items_lookup[item_id]["name"])
					else:
						item_names.append(f"Unknown(${item_id:02x})")
				lines.append(f"; Items: {', '.join(item_names)}")

			lines.append(f"; -----------------------------------------------------------------------------")
			lines.append(f"{label}:")

			if item_ids:
				# Output each item with its constant label and comment
				for j, item_id in enumerate(item_ids):
					if item_id in items_lookup:
						info = items_lookup[item_id]
						item_label = info["label"]
						item_name = info["name"]
						item_type = info["type"]
						lines.append(f"\t.db {item_label}\t\t; {j + 1}. {item_name} ({item_type})")
					else:
						lines.append(f"\t.db ${item_id:02x}\t\t\t; {j + 1}. Unknown item ${item_id:02x}")

			lines.append(f"\t.db SHOP_END\t\t\t; End of shop")

		lines.extend([
			"",
			"; ============================================================================",
			"; End of shop data",
			"; ============================================================================",
		])

		output_path.parent.mkdir(parents=True, exist_ok=True)
		with open(output_path, "w", encoding="utf-8") as f:
			f.write("\n".join(lines))

		self.console.print(f"[green]âœ“ Written {len(shops)} shops to {output_path}[/green]")
		self.console.print(f"[green]  - {len(used_items)} unique item constants generated[/green]")

	def convert_all(self):
		"""
		Convert all JSON data files to Poppy assembly.

		This is the main entry point for the asset pipeline's code generation step.
		Converts all supported data types from JSON to .pasm files.
		"""
		# Define all conversions: (input_path, output_path, converter_method)
		# Note: Output uses .pasm extension for Poppy assembler
		conversions = [
			(ASSETS_JSON_DIR / "monsters" / "monsters.json", SOURCE_DATA_DIR / "monsters.pasm", self.convert_monsters),
			(ASSETS_JSON_DIR / "items" / "items.json", SOURCE_DATA_DIR / "items.pasm", self.convert_items),
			(ASSETS_JSON_DIR / "spells" / "spells.json", SOURCE_DATA_DIR / "spells.pasm", self.convert_spells),
			(ASSETS_JSON_DIR / "shops.json", SOURCE_DATA_DIR / "shops.pasm", self.convert_shops),
		]

		self.console.print("[bold cyan]ðŸŒ· Flower Toolchain - JSON to Assembly Converter[/bold cyan]")
		self.console.print("")

		success_count = 0
		skip_count = 0

		for input_path, output_path, converter in conversions:
			if input_path.exists():
				converter(input_path, output_path)
				success_count += 1
			else:
				self.console.print(f"[yellow]âš  Skipping {input_path.name} (not found)[/yellow]")
				skip_count += 1

		self.console.print("")
		self.console.print(f"[bold green]âœ“ Conversion complete: {success_count} files converted, {skip_count} skipped[/bold green]")


@click.group()
def cli():
	"""
	ðŸŒ· JSON to Poppy Assembly converter for Dragon Warrior IV.

	Part of the Flower Toolchain asset pipeline.
	Converts JSON data files to .pasm assembly source files.
	"""
	pass


@cli.command()
def monsters():
	"""Convert monster data to Poppy assembly."""
	converter = JsonToAsmConverter()
	input_path = ASSETS_JSON_DIR / "monsters" / "monsters.json"
	output_path = SOURCE_DATA_DIR / "monsters.pasm"
	if input_path.exists():
		converter.convert_monsters(input_path, output_path)
	else:
		console.print(f"[red]Error: {input_path} not found[/red]")


@cli.command()
def items():
	"""Convert item data to Poppy assembly."""
	converter = JsonToAsmConverter()
	input_path = ASSETS_JSON_DIR / "items" / "items.json"
	output_path = SOURCE_DATA_DIR / "items.pasm"
	if input_path.exists():
		converter.convert_items(input_path, output_path)
	else:
		console.print(f"[red]Error: {input_path} not found[/red]")


@cli.command()
def spells():
	"""Convert spell data to Poppy assembly."""
	converter = JsonToAsmConverter()
	input_path = ASSETS_JSON_DIR / "spells" / "spells.json"
	output_path = SOURCE_DATA_DIR / "spells.pasm"
	if input_path.exists():
		converter.convert_spells(input_path, output_path)
	else:
		console.print(f"[red]Error: {input_path} not found[/red]")


@cli.command()
def shops():
	"""Convert shop data to Poppy assembly."""
	converter = JsonToAsmConverter()
	input_path = ASSETS_JSON_DIR / "shops.json"
	output_path = SOURCE_DATA_DIR / "shops.pasm"
	if input_path.exists():
		converter.convert_shops(input_path, output_path)
	else:
		console.print(f"[red]Error: {input_path} not found[/red]")


@cli.command("all")
def convert_all():
	"""Convert all data files to Poppy assembly."""
	converter = JsonToAsmConverter()
	converter.convert_all()


if __name__ == "__main__":
	cli()
