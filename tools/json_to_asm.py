#!/usr/bin/env python3
"""
JSON to Poppy Assembly Converter for Dragon Warrior IV
ðŸŒ· Flower Toolchain Integration

Converts extracted JSON data files to Poppy-compatible assembly source files (.pasm).
This is part of the ðŸŒ· Flower Toolchain build pipeline:

	ROM â†’ ðŸŒº Peony (disassemble) â†’ Source + ðŸŒ¼ Pansy (metadata)
	         â†’ Edit JSON assets â†’
	JSON â†’ json_to_asm.py â†’ .pasm â†’ ðŸŒ¸ Poppy (assemble) â†’ ROM

Usage:
	python json_to_asm.py monsters    # Convert monsters.json to monsters.pasm
	python json_to_asm.py items       # Convert items.json to items.pasm
	python json_to_asm.py all         # Convert all data files

Poppy Assembly Syntax:
	- .db for bytes, .dw for words (little-endian)
	- Labels end with colon (label:)
	- Comments use semicolon (;)
	- Hex values use $ prefix ($ff)
	- All opcodes/values in lowercase
"""

import json
from pathlib import Path
from typing import Dict, List, Any

import click
from rich.console import Console

# Project paths
PROJECT_ROOT = Path(__file__).parent.parent
ASSETS_JSON_DIR = PROJECT_ROOT / "assets" / "json"
SOURCE_DATA_DIR = PROJECT_ROOT / "src" / "data"  # Updated path for Poppy structure

console = Console()


def format_hex_byte(value: int) -> str:
	"""Format a byte value as hex for assembly."""
	return f"${value:02x}"


def format_hex_word(value: int) -> str:
	"""Format a 16-bit word as hex for assembly."""
	return f"${value:04x}"


def sanitize_label(name: str) -> str:
	"""Convert a name to a valid assembly label."""
	# Replace spaces and special chars with underscores
	label = name.lower()
	label = label.replace(" ", "_")
	label = label.replace("-", "_")
	label = label.replace("'", "")
	label = label.replace(".", "")
	label = label.replace(",", "")
	label = label.replace("!", "")
	label = label.replace("?", "")
	label = label.replace("(", "")
	label = label.replace(")", "")
	# Ensure it starts with a letter
	if label and label[0].isdigit():
		label = "_" + label
	return label


class JsonToAsmConverter:
	"""
	Converts JSON data to Poppy assembly source (.pasm files).

	ðŸŒ· Flower Toolchain component for asset pipeline integration.
	Generates properly formatted assembly code with:
	- Full comments documenting data structures
	- Named labels for each entry
	- Proper Poppy syntax (.db, .dw directives)
	- Lowercase hex values with $ prefix
	"""

	def __init__(self):
		self.console = Console()

	def convert_monsters(self, input_path: Path, output_path: Path):
		"""
		Convert monster data JSON to Poppy assembly.

		Monster data structure (16 bytes per entry):
		- Offset $00: HP (2 bytes, little-endian)
		- Offset $02: MP (1 byte)
		- Offset $03: Attack (2 bytes, little-endian)
		- Offset $05: Defense (1 byte)
		- Offset $06: Agility (1 byte)
		- Offset $07: Experience (2 bytes, little-endian)
		- Offset $09: Gold (2 bytes, little-endian)
		- Offset $0b: Drop item ID (1 byte)
		- Offset $0c: Drop rate denominator (1 byte, 1/N chance)
		- Offset $0d: Action pattern (1 byte)
		- Offset $0e: Resistances bitmask (1 byte)
		- Offset $0f: Sprite/palette info (1 byte)
		"""
		self.console.print(f"[cyan]ðŸŒ· Converting monsters: {input_path}[/cyan]")

		with open(input_path, "r", encoding="utf-8") as f:
			data = json.load(f)

		lines = [
			"; ============================================================================",
			"; Dragon Warrior IV - Monster Data",
			"; ðŸŒ· Generated by json_to_asm.py for Poppy assembler",
			"; ============================================================================",
			";",
			"; Monster data structure (16 bytes per entry):",
			";   Offset  Size  Description",
			";   $00     2     HP (little-endian word)",
			";   $02     1     MP",
			";   $03     2     Attack (little-endian word)",
			";   $05     1     Defense",
			";   $06     1     Agility",
			";   $07     2     Experience (little-endian word)",
			";   $09     2     Gold (little-endian word)",
			";   $0b     1     Drop item ID",
			";   $0c     1     Drop rate (1/N chance)",
			";   $0d     1     Action pattern",
			";   $0e     1     Resistances (bitmask)",
			";   $0f     1     Sprite/palette info",
			";",
			"; ============================================================================",
			"",
			"; -----------------------------------------------------------------------------",
			"; Monster count constant",
			"; -----------------------------------------------------------------------------",
			f"MONSTER_COUNT = {len(data.get('monsters', []))}",
			"",
			"; -----------------------------------------------------------------------------",
			"; Monster stat table",
			"; Located in PRG Bank 08",
			"; -----------------------------------------------------------------------------",
			"monster_stats_table:",
		]

		monsters = data.get("monsters", [])
		for monster in monsters:
			monster_id = monster.get("id", 0)
			name = monster.get("name", f"Monster_{monster_id:03d}")
			hp = monster.get("hp", 0)
			mp = monster.get("mp", 0)
			attack = monster.get("attack", 0)
			defense = monster.get("defense", 0)
			agility = monster.get("agility", 0)
			exp = monster.get("exp", 0)
			gold = monster.get("gold", 0)
			drop_item = monster.get("drop_item_id", 0)
			drop_rate = monster.get("drop_rate", 0)
			action = monster.get("action_pattern", 0)
			resist = monster.get("resistances", 0)
			sprite = monster.get("sprite_info", 0)

			# Create sanitized label from name
			label = sanitize_label(name)

			lines.append(f"")
			lines.append(f"; Monster ${monster_id:02x}: {name}")
			lines.append(f"monster_{monster_id:03d}:")
			lines.append(f"monster_{label}:")
			lines.append(f"\t.dw {format_hex_word(hp)}\t\t\t; HP = {hp}")
			lines.append(f"\t.db {format_hex_byte(mp)}\t\t\t\t; MP = {mp}")
			lines.append(f"\t.dw {format_hex_word(attack)}\t\t\t; Attack = {attack}")
			lines.append(f"\t.db {format_hex_byte(defense)}\t\t\t\t; Defense = {defense}")
			lines.append(f"\t.db {format_hex_byte(agility)}\t\t\t\t; Agility = {agility}")
			lines.append(f"\t.dw {format_hex_word(exp)}\t\t\t; Experience = {exp}")
			lines.append(f"\t.dw {format_hex_word(gold)}\t\t\t; Gold = {gold}")
			lines.append(f"\t.db {format_hex_byte(drop_item)}\t\t\t\t; Drop item ID")
			lines.append(f"\t.db {format_hex_byte(drop_rate)}\t\t\t\t; Drop rate (1/{drop_rate if drop_rate else 'N/A'})")
			lines.append(f"\t.db {format_hex_byte(action)}\t\t\t\t; Action pattern")
			lines.append(f"\t.db {format_hex_byte(resist)}\t\t\t\t; Resistances")
			lines.append(f"\t.db {format_hex_byte(sprite)}\t\t\t\t; Sprite info")

		lines.extend([
			"",
			"; ============================================================================",
			"; End of monster data",
			"; ============================================================================",
		])

		output_path.parent.mkdir(parents=True, exist_ok=True)
		with open(output_path, "w", encoding="utf-8") as f:
			f.write("\n".join(lines))

		self.console.print(f"[green]âœ“ Written {len(monsters)} monsters to {output_path}[/green]")

	def convert_items(self, input_path: Path, output_path: Path):
		"""
		Convert item data JSON to Poppy assembly.

		Item data structure (8 bytes per entry):
		- Offset $00: Price (2 bytes, little-endian)
		- Offset $02: Attack bonus (1 byte)
		- Offset $03: Defense bonus (1 byte)
		- Offset $04: Agility bonus (1 byte, signed)
		- Offset $05: Equip flags (1 byte, bitmask for who can equip)
		- Offset $06: Effect ID (1 byte)
		- Offset $07: Item type (1 byte)
		"""
		self.console.print(f"[cyan]ðŸŒ· Converting items: {input_path}[/cyan]")

		with open(input_path, "r", encoding="utf-8") as f:
			data = json.load(f)

		lines = [
			"; ============================================================================",
			"; Dragon Warrior IV - Item Data",
			"; ðŸŒ· Generated by json_to_asm.py for Poppy assembler",
			"; ============================================================================",
			";",
			"; Item data structure (8 bytes per entry):",
			";   Offset  Size  Description",
			";   $00     2     Price (little-endian word)",
			";   $02     1     Attack bonus",
			";   $03     1     Defense bonus",
			";   $04     1     Agility bonus (signed byte)",
			";   $05     1     Equip flags (who can equip)",
			";   $06     1     Effect ID",
			";   $07     1     Item type",
			";",
			"; Equip flags bitmask:",
			";   Bit 0: Hero        Bit 4: Alena",
			";   Bit 1: Ragnar      Bit 5: Brey",
			";   Bit 2: Taloon      Bit 6: Cristo",
			";   Bit 3: Nara        Bit 7: Mara",
			";",
			"; ============================================================================",
			"",
			"; -----------------------------------------------------------------------------",
			"; Item count constant",
			"; -----------------------------------------------------------------------------",
			f"ITEM_COUNT = {len(data.get('items', []))}",
			"",
			"; -----------------------------------------------------------------------------",
			"; Item stat table",
			"; Located in PRG Bank 08",
			"; -----------------------------------------------------------------------------",
			"item_stats_table:",
		]

		items = data.get("items", [])
		for item in items:
			item_id = item.get("id", 0)
			name = item.get("name", f"Item_{item_id:03d}")
			price = item.get("price", 0)
			attack = item.get("attack_bonus", 0)
			defense = item.get("defense_bonus", 0)
			agility = item.get("agility_bonus", 0)
			equip = item.get("equip_flags", 0)
			effect = item.get("effect_id", 0)
			item_type = item.get("item_type", 0)

			# Handle signed agility bonus (convert negative to unsigned byte)
			if agility < 0:
				agility = 256 + agility

			# Create sanitized label from name
			label = sanitize_label(name)

			lines.append(f"")
			lines.append(f"; Item ${item_id:02x}: {name}")
			lines.append(f"item_{item_id:03d}:")
			lines.append(f"item_{label}:")
			lines.append(f"\t.dw {format_hex_word(price)}\t\t\t; Price = {price}G")
			lines.append(f"\t.db {format_hex_byte(attack)}\t\t\t\t; Attack +{attack}")
			lines.append(f"\t.db {format_hex_byte(defense)}\t\t\t\t; Defense +{defense}")
			lines.append(f"\t.db {format_hex_byte(agility)}\t\t\t\t; Agility bonus")
			lines.append(f"\t.db {format_hex_byte(equip)}\t\t\t\t; Equip flags")
			lines.append(f"\t.db {format_hex_byte(effect)}\t\t\t\t; Effect ID")
			lines.append(f"\t.db {format_hex_byte(item_type)}\t\t\t\t; Item type")

		lines.extend([
			"",
			"; ============================================================================",
			"; End of item data",
			"; ============================================================================",
		])

		output_path.parent.mkdir(parents=True, exist_ok=True)
		with open(output_path, "w", encoding="utf-8") as f:
			f.write("\n".join(lines))

		self.console.print(f"[green]âœ“ Written {len(items)} items to {output_path}[/green]")

	def convert_spells(self, input_path: Path, output_path: Path):
		"""
		Convert spell data JSON to Poppy assembly.

		Spell data structure (8 bytes per entry):
		- Offset $00: MP cost (1 byte)
		- Offset $01: Effect type (1 byte)
		- Offset $02: Power/healing amount (1 byte)
		- Offset $03: Target type (1 byte)
		- Offset $04: Element (1 byte)
		- Offset $05: Accuracy (1 byte)
		- Offset $06: Flags (2 bytes, little-endian)
		"""
		self.console.print(f"[cyan]ðŸŒ· Converting spells: {input_path}[/cyan]")

		with open(input_path, "r", encoding="utf-8") as f:
			data = json.load(f)

		lines = [
			"; ============================================================================",
			"; Dragon Warrior IV - Spell Data",
			"; ðŸŒ· Generated by json_to_asm.py for Poppy assembler",
			"; ============================================================================",
			";",
			"; Spell data structure (8 bytes per entry):",
			";   Offset  Size  Description",
			";   $00     1     MP cost",
			";   $01     1     Effect type",
			";   $02     1     Power/healing amount",
			";   $03     1     Target type (0=self, 1=ally, 2=all, 3=enemy, 4=group)",
			";   $04     1     Element (0=none, 1=fire, 2=ice, 3=electric, etc.)",
			";   $05     1     Accuracy (0-255)",
			";   $06     2     Flags (little-endian word)",
			";",
			"; ============================================================================",
			"",
			"; -----------------------------------------------------------------------------",
			"; Spell count constant",
			"; -----------------------------------------------------------------------------",
			f"SPELL_COUNT = {len(data.get('spells', []))}",
			"",
			"; -----------------------------------------------------------------------------",
			"; Spell data table",
			"; Located in PRG Bank 08",
			"; -----------------------------------------------------------------------------",
			"spell_data_table:",
		]

		spells = data.get("spells", [])
		for spell in spells:
			spell_id = spell.get("id", 0)
			name = spell.get("name", f"Spell_{spell_id:03d}")
			mp_cost = spell.get("mp_cost", 0)
			effect = spell.get("effect_type", 0)
			power = spell.get("power", 0)
			target = spell.get("target_type", 0)
			element = spell.get("element", 0)
			accuracy = spell.get("accuracy", 100)
			flags = spell.get("flags", 0)

			# Create sanitized label from name
			label = sanitize_label(name)

			lines.append(f"")
			lines.append(f"; Spell ${spell_id:02x}: {name}")
			lines.append(f"spell_{spell_id:03d}:")
			lines.append(f"spell_{label}:")
			lines.append(f"\t.db {format_hex_byte(mp_cost)}\t\t\t\t; MP cost = {mp_cost}")
			lines.append(f"\t.db {format_hex_byte(effect)}\t\t\t\t; Effect type")
			lines.append(f"\t.db {format_hex_byte(power)}\t\t\t\t; Power = {power}")
			lines.append(f"\t.db {format_hex_byte(target)}\t\t\t\t; Target type")
			lines.append(f"\t.db {format_hex_byte(element)}\t\t\t\t; Element")
			lines.append(f"\t.db {format_hex_byte(accuracy)}\t\t\t\t; Accuracy")
			lines.append(f"\t.dw {format_hex_word(flags)}\t\t\t; Flags")

		lines.extend([
			"",
			"; ============================================================================",
			"; End of spell data",
			"; ============================================================================",
		])

		output_path.parent.mkdir(parents=True, exist_ok=True)
		with open(output_path, "w", encoding="utf-8") as f:
			f.write("\n".join(lines))

		self.console.print(f"[green]âœ“ Written {len(spells)} spells to {output_path}[/green]")

	def convert_shops(self, input_path: Path, output_path: Path):
		"""
		Convert shop data JSON to Poppy assembly.

		Shop format: Pointer table followed by item lists.
		Each shop is a list of item IDs terminated by $FF.
		"""
		self.console.print(f"[cyan]ðŸŒ· Converting shops: {input_path}[/cyan]")

		with open(input_path, "r", encoding="utf-8") as f:
			data = json.load(f)

		lines = [
			"; ============================================================================",
			"; Dragon Warrior IV - Shop Data",
			"; ðŸŒ· Generated by json_to_asm.py for Poppy assembler",
			"; ============================================================================",
			";",
			"; Shop format:",
			";   - Pointer table: .dw shop_000, shop_001, ...",
			";   - Each shop: list of item IDs terminated by $ff",
			";",
			"; ============================================================================",
			"",
		]

		shops = data.get("shops", [])
		lines.append(f"; -----------------------------------------------------------------------------")
		lines.append(f"; Shop count constant")
		lines.append(f"; -----------------------------------------------------------------------------")
		lines.append(f"SHOP_COUNT = {len(shops)}")
		lines.append("")

		# Pointer table
		lines.append("; -----------------------------------------------------------------------------")
		lines.append("; Shop pointer table")
		lines.append("; -----------------------------------------------------------------------------")
		lines.append("shop_pointer_table:")
		for i, shop in enumerate(shops):
			shop_name = shop.get("name", f"Shop {i}")
			lines.append(f"\t.dw shop_{i:03d}\t\t\t; {shop_name}")
		lines.append("")

		# Shop data
		lines.append("; -----------------------------------------------------------------------------")
		lines.append("; Shop data (item lists)")
		lines.append("; -----------------------------------------------------------------------------")
		for i, shop in enumerate(shops):
			shop_name = shop.get("name", f"Shop {i}")
			location = shop.get("location", "Unknown")
			item_ids = shop.get("item_ids", [])

			lines.append(f"")
			lines.append(f"; Shop ${i:02x}: {shop_name}")
			if location != "Unknown":
				lines.append(f"; Location: {location}")
			lines.append(f"shop_{i:03d}:")

			if item_ids:
				# Output items in groups of 8 for readability
				for j in range(0, len(item_ids), 8):
					chunk = item_ids[j:j + 8]
					items_str = ", ".join(format_hex_byte(item) for item in chunk)
					lines.append(f"\t.db {items_str}")

			lines.append(f"\t.db $ff\t\t\t\t; End of shop")

		lines.extend([
			"",
			"; ============================================================================",
			"; End of shop data",
			"; ============================================================================",
		])

		output_path.parent.mkdir(parents=True, exist_ok=True)
		with open(output_path, "w", encoding="utf-8") as f:
			f.write("\n".join(lines))

		self.console.print(f"[green]âœ“ Written {len(shops)} shops to {output_path}[/green]")

	def convert_all(self):
		"""
		Convert all JSON data files to Poppy assembly.

		This is the main entry point for the asset pipeline's code generation step.
		Converts all supported data types from JSON to .pasm files.
		"""
		# Define all conversions: (input_path, output_path, converter_method)
		# Note: Output uses .pasm extension for Poppy assembler
		conversions = [
			(ASSETS_JSON_DIR / "monsters" / "monsters.json", SOURCE_DATA_DIR / "monsters.pasm", self.convert_monsters),
			(ASSETS_JSON_DIR / "items" / "items.json", SOURCE_DATA_DIR / "items.pasm", self.convert_items),
			(ASSETS_JSON_DIR / "spells" / "spells.json", SOURCE_DATA_DIR / "spells.pasm", self.convert_spells),
			(ASSETS_JSON_DIR / "shops.json", SOURCE_DATA_DIR / "shops.pasm", self.convert_shops),
		]

		self.console.print("[bold cyan]ðŸŒ· Flower Toolchain - JSON to Assembly Converter[/bold cyan]")
		self.console.print("")

		success_count = 0
		skip_count = 0

		for input_path, output_path, converter in conversions:
			if input_path.exists():
				converter(input_path, output_path)
				success_count += 1
			else:
				self.console.print(f"[yellow]âš  Skipping {input_path.name} (not found)[/yellow]")
				skip_count += 1

		self.console.print("")
		self.console.print(f"[bold green]âœ“ Conversion complete: {success_count} files converted, {skip_count} skipped[/bold green]")


@click.group()
def cli():
	"""
	ðŸŒ· JSON to Poppy Assembly converter for Dragon Warrior IV.

	Part of the Flower Toolchain asset pipeline.
	Converts JSON data files to .pasm assembly source files.
	"""
	pass


@cli.command()
def monsters():
	"""Convert monster data to Poppy assembly."""
	converter = JsonToAsmConverter()
	input_path = ASSETS_JSON_DIR / "monsters" / "monsters.json"
	output_path = SOURCE_DATA_DIR / "monsters.pasm"
	if input_path.exists():
		converter.convert_monsters(input_path, output_path)
	else:
		console.print(f"[red]Error: {input_path} not found[/red]")


@cli.command()
def items():
	"""Convert item data to Poppy assembly."""
	converter = JsonToAsmConverter()
	input_path = ASSETS_JSON_DIR / "items" / "items.json"
	output_path = SOURCE_DATA_DIR / "items.pasm"
	if input_path.exists():
		converter.convert_items(input_path, output_path)
	else:
		console.print(f"[red]Error: {input_path} not found[/red]")


@cli.command()
def spells():
	"""Convert spell data to Poppy assembly."""
	converter = JsonToAsmConverter()
	input_path = ASSETS_JSON_DIR / "spells" / "spells.json"
	output_path = SOURCE_DATA_DIR / "spells.pasm"
	if input_path.exists():
		converter.convert_spells(input_path, output_path)
	else:
		console.print(f"[red]Error: {input_path} not found[/red]")


@cli.command()
def shops():
	"""Convert shop data to Poppy assembly."""
	converter = JsonToAsmConverter()
	input_path = ASSETS_JSON_DIR / "shops.json"
	output_path = SOURCE_DATA_DIR / "shops.pasm"
	if input_path.exists():
		converter.convert_shops(input_path, output_path)
	else:
		console.print(f"[red]Error: {input_path} not found[/red]")


@cli.command("all")
def convert_all():
	"""Convert all data files to Poppy assembly."""
	converter = JsonToAsmConverter()
	converter.convert_all()


if __name__ == "__main__":
	cli()
